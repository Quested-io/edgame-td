import {
  require_Reflect
} from "./chunk-4YXOSJ2Q.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-OCBYBPSH.js";

// ../../node_modules/.pnpm/@quested+sdk@0.1.7_reflect-metadata@0.1.14/node_modules/@quested/sdk/dist/index.mjs
var import_reflect_metadata2 = __toESM(require_Reflect(), 1);

// ../../node_modules/.pnpm/inversify@6.2.0_reflect-metadata@0.1.14/node_modules/inversify/lib/esm/index.js
var import_reflect_metadata = __toESM(require_Reflect());

// ../../node_modules/.pnpm/@inversifyjs+common@1.4.0/node_modules/@inversifyjs/common/lib/esm/index.js
var t = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var _a, _e;
_a = t;
var r = class {
  constructor(e2) {
    __publicField(this, _a);
    __privateAdd(this, _e);
    __privateSet(this, _e, e2), this[t] = true;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[t];
  }
  unwrap() {
    return __privateGet(this, _e).call(this);
  }
};
_e = new WeakMap();

// ../../node_modules/.pnpm/@inversifyjs+reflect-metadata-utils@0.2.4_reflect-metadata@0.1.14/node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
function t2(t3, e2) {
  return Reflect.getMetadata(e2, t3);
}
function e(e2, n, a3, c3) {
  const f3 = c3(t2(e2, n) ?? a3);
  Reflect.defineMetadata(n, f3, e2);
}

// ../../node_modules/.pnpm/@inversifyjs+core@1.3.5_reflect-metadata@0.1.14/node_modules/@inversifyjs/core/lib/esm/index.js
var a = "named";
var r2 = "name";
var i = "unmanaged";
var o = "optional";
var s = "inject";
var c = "multi_inject";
var u = "post_construct";
var d = "pre_destroy";
var m = [s, c, r2, i, a, o];
var l = Symbol.for("@inversifyjs/core/InversifyCoreError");
var _a2, _b;
var f = class _f extends (_b = Error, _a2 = l, _b) {
  constructor(t3, e2, n) {
    super(e2, n);
    __publicField(this, _a2);
    __publicField(this, "kind");
    this[l] = true, this.kind = t3;
  }
  static is(t3) {
    return "object" == typeof t3 && null !== t3 && true === t3[l];
  }
  static isErrorOfKind(t3, e2) {
    return _f.is(t3) && t3.kind === e2;
  }
};
var g;
var p;
function h(t3, e2) {
  const n = [];
  for (let t4 = 0; t4 < e2.length; ++t4) {
    void 0 === e2[t4] && n.push(t4);
  }
  if (n.length > 0) throw new f(g.missingInjectionDecorator, `Found unexpected missing metadata on type "${t3.name}" at constructor indexes "${n.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
}
function y(t3) {
  return { kind: p.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), targetName: void 0, value: t3 };
}
function v(t3) {
  const e2 = t3.find((t4) => t4.key === s), n = t3.find((t4) => t4.key === c);
  if (void 0 !== t3.find((t4) => t4.key === i)) return function(t4, e3) {
    if (void 0 !== e3 || void 0 !== t4) throw new f(g.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
    return { kind: p.unmanaged };
  }(e2, n);
  if (void 0 === n && void 0 === e2) throw new f(g.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
  const u3 = t3.find((t4) => t4.key === a), d3 = t3.find((t4) => t4.key === o), l3 = t3.find((t4) => t4.key === r2);
  return { kind: void 0 === e2 ? p.multipleInjection : p.singleInjection, name: u3 == null ? void 0 : u3.value, optional: void 0 !== d3, tags: new Map(t3.filter((t4) => m.every((e3) => t4.key !== e3)).map((t4) => [t4.key, t4.value])), targetName: l3 == null ? void 0 : l3.value, value: void 0 === e2 ? n == null ? void 0 : n.value : e2.value };
}
function j(t3, e2, n) {
  try {
    return v(n);
  } catch (n2) {
    throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at constructor arguments at index "${e2.toString()}"`, { cause: n2 }) : n2;
  }
}
function k(e2) {
  const n = t2(e2, "design:paramtypes"), a3 = t2(e2, "inversify:tagged"), r4 = [];
  if (void 0 !== a3) for (const [t3, n2] of Object.entries(a3)) {
    const a4 = parseInt(t3);
    r4[a4] = j(e2, a4, n2);
  }
  if (void 0 !== n) {
    for (let t3 = 0; t3 < n.length; ++t3) if (void 0 === r4[t3]) {
      const e3 = n[t3];
      r4[t3] = y(e3);
    }
  }
  return h(e2, r4), r4;
}
function I(t3, e2, n) {
  try {
    return v(n);
  } catch (n2) {
    throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at property "${e2.toString()}"`, { cause: n2 }) : n2;
  }
}
function w(e2) {
  const n = t2(e2, "inversify:tagged_props"), a3 = /* @__PURE__ */ new Map();
  if (void 0 !== n) for (const t3 of Reflect.ownKeys(n)) {
    const r4 = n[t3];
    a3.set(t3, I(e2, t3, r4));
  }
  return a3;
}
function M(e2) {
  const n = t2(e2, u), a3 = t2(e2, d);
  return { constructorArguments: k(e2), lifecycle: { postConstructMethodName: n == null ? void 0 : n.value, preDestroyMethodName: a3 == null ? void 0 : a3.value }, properties: w(e2) };
}
function N(t3, e2) {
  const n = e2.getConstructorMetadata(t3), a3 = [];
  for (const [e3, r4] of Object.entries(n.userGeneratedMetadata)) {
    const n2 = parseInt(e3);
    a3[n2] = j(t3, n2, r4);
  }
  if (void 0 !== n.compilerGeneratedMetadata) {
    for (let t4 = 0; t4 < n.compilerGeneratedMetadata.length; ++t4) if (void 0 === a3[t4]) {
      const e3 = n.compilerGeneratedMetadata[t4];
      a3[t4] = y(e3);
    }
  }
  return h(t3, a3), a3;
}
function E(t3, e2) {
  const n = e2.getPropertiesMetadata(t3), a3 = /* @__PURE__ */ new Map();
  for (const e3 of Reflect.ownKeys(n)) {
    const r4 = n[e3];
    a3.set(e3, I(t3, e3, r4));
  }
  return a3;
}
function D(e2, n) {
  const a3 = t2(e2, u), r4 = t2(e2, d);
  return { constructorArguments: N(e2, n), lifecycle: { postConstructMethodName: a3 == null ? void 0 : a3.value, preDestroyMethodName: r4 == null ? void 0 : r4.value }, properties: E(e2, n) };
}
function b(t3) {
  const e2 = Object.getPrototypeOf(t3.prototype), n = e2 == null ? void 0 : e2.constructor;
  return n;
}
function O(t3) {
  return t3.kind === p.unmanaged ? [{ key: i, value: true }] : function(t4) {
    const e2 = [A(t4)];
    void 0 !== t4.name && e2.push({ key: a, value: t4.name });
    t4.optional && e2.push({ key: o, value: true });
    for (const [n, a3] of t4.tags) e2.push({ key: n, value: a3 });
    void 0 !== t4.targetName && e2.push({ key: r2, value: t4.targetName });
    return e2;
  }(t3);
}
function A(t3) {
  let e2;
  switch (t3.kind) {
    case p.multipleInjection:
      e2 = { key: c, value: t3.value };
      break;
    case p.singleInjection:
      e2 = { key: s, value: t3.value };
  }
  return e2;
}
!function(t3) {
  t3[t3.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", t3[t3.missingInjectionDecorator = 1] = "missingInjectionDecorator", t3[t3.planning = 2] = "planning", t3[t3.unknown = 3] = "unknown";
}(g || (g = {})), function(t3) {
  t3[t3.multipleInjection = 0] = "multipleInjection", t3[t3.singleInjection = 1] = "singleInjection", t3[t3.unmanaged = 2] = "unmanaged";
}(p || (p = {}));
var _t;
var x = class {
  constructor(t3) {
    __privateAdd(this, _t);
    __privateSet(this, _t, t3);
  }
  startsWith(t3) {
    return __privateGet(this, _t).startsWith(t3);
  }
  endsWith(t3) {
    return __privateGet(this, _t).endsWith(t3);
  }
  contains(t3) {
    return __privateGet(this, _t).includes(t3);
  }
  equals(t3) {
    return __privateGet(this, _t) === t3;
  }
  value() {
    return __privateGet(this, _t);
  }
};
_t = new WeakMap();
var C = "@inversifyjs/core/targetId";
var _e2, _n, _a3, _r, _i, _o;
var T = class {
  constructor(n, a3, r4) {
    __privateAdd(this, _e2);
    __privateAdd(this, _n);
    __privateAdd(this, _a3);
    __privateAdd(this, _r);
    __privateAdd(this, _i);
    __privateAdd(this, _o);
    __privateSet(this, _n, function() {
      const n2 = t2(Object, C) ?? 0;
      return n2 === Number.MAX_SAFE_INTEGER ? e(Object, C, n2, () => Number.MIN_SAFE_INTEGER) : e(Object, C, n2, (t3) => t3 + 1), n2;
    }()), __privateSet(this, _a3, n), __privateSet(this, _r, void 0), __privateSet(this, _e2, a3), __privateSet(this, _i, new x("string" == typeof n ? n : n.toString().slice(7, -1))), __privateSet(this, _o, r4);
  }
  get id() {
    return __privateGet(this, _n);
  }
  get identifier() {
    return __privateGet(this, _a3);
  }
  get metadata() {
    return void 0 === __privateGet(this, _r) && __privateSet(this, _r, O(__privateGet(this, _e2))), __privateGet(this, _r);
  }
  get name() {
    return __privateGet(this, _i);
  }
  get type() {
    return __privateGet(this, _o);
  }
  get serviceIdentifier() {
    return r.is(__privateGet(this, _e2).value) ? __privateGet(this, _e2).value.unwrap() : __privateGet(this, _e2).value;
  }
  getCustomTags() {
    return [...__privateGet(this, _e2).tags.entries()].map(([t3, e2]) => ({ key: t3, value: e2 }));
  }
  getNamedTag() {
    return void 0 === __privateGet(this, _e2).name ? null : { key: a, value: __privateGet(this, _e2).name };
  }
  hasTag(t3) {
    return this.metadata.some((e2) => e2.key === t3);
  }
  isArray() {
    return __privateGet(this, _e2).kind === p.multipleInjection;
  }
  isNamed() {
    return void 0 !== __privateGet(this, _e2).name;
  }
  isOptional() {
    return __privateGet(this, _e2).optional;
  }
  isTagged() {
    return __privateGet(this, _e2).tags.size > 0;
  }
  matchesArray(t3) {
    return this.isArray() && __privateGet(this, _e2).value === t3;
  }
  matchesNamedTag(t3) {
    return __privateGet(this, _e2).name === t3;
  }
  matchesTag(t3) {
    return (e2) => this.metadata.some((n) => n.key === t3 && n.value === e2);
  }
};
_e2 = new WeakMap();
_n = new WeakMap();
_a3 = new WeakMap();
_r = new WeakMap();
_i = new WeakMap();
_o = new WeakMap();
var _ = (t3) => /* @__PURE__ */ function(t4, e2) {
  return function(n) {
    const a3 = t4(n);
    let r4 = b(n);
    for (; void 0 !== r4 && r4 !== Object; ) {
      const t5 = e2(r4);
      for (const [e3, n2] of t5) a3.properties.has(e3) || a3.properties.set(e3, n2);
      r4 = b(r4);
    }
    const i2 = [];
    for (const t5 of a3.constructorArguments) if (t5.kind !== p.unmanaged) {
      const e3 = t5.targetName ?? "";
      i2.push(new T(e3, t5, "ConstructorArgument"));
    }
    for (const [t5, e3] of a3.properties) if (e3.kind !== p.unmanaged) {
      const n2 = e3.targetName ?? t5;
      i2.push(new T(n2, e3, "ClassProperty"));
    }
    return i2;
  };
}(void 0 === t3 ? M : (e2) => D(e2, t3), void 0 === t3 ? w : (e2) => E(e2, t3));

// ../../node_modules/.pnpm/inversify@6.2.0_reflect-metadata@0.1.14/node_modules/inversify/lib/esm/index.js
var r3 = "named";
var s2 = "name";
var o2 = "unmanaged";
var a2 = "optional";
var c2 = "inject";
var d2 = "multi_inject";
var u2 = "inversify:tagged";
var h2 = "inversify:tagged_props";
var l2 = "inversify:paramtypes";
var g2 = "design:paramtypes";
var y2 = "post_construct";
var p2 = "pre_destroy";
var f2 = [c2, d2, s2, o2, r3, a2];
var _2 = Object.freeze({ __proto__: null, DESIGN_PARAM_TYPES: g2, INJECT_TAG: c2, MULTI_INJECT_TAG: d2, NAMED_TAG: r3, NAME_TAG: s2, NON_CUSTOM_TAG_KEYS: f2, OPTIONAL_TAG: a2, PARAM_TYPES: l2, POST_CONSTRUCT: y2, PRE_DESTROY: p2, TAGGED: u2, TAGGED_PROP: h2, UNMANAGED_TAG: o2 });
var v2 = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
var b2 = { ConstantValue: "ConstantValue", Constructor: "Constructor", DynamicValue: "DynamicValue", Factory: "Factory", Function: "Function", Instance: "Instance", Invalid: "Invalid", Provider: "Provider" };
var w2 = { ClassProperty: "ClassProperty", ConstructorArgument: "ConstructorArgument", Variable: "Variable" };
var m2 = 0;
function A2() {
  return m2++;
}
var S = class _S {
  constructor(t3, n) {
    __publicField(this, "id");
    __publicField(this, "moduleId");
    __publicField(this, "activated");
    __publicField(this, "serviceIdentifier");
    __publicField(this, "implementationType");
    __publicField(this, "cache");
    __publicField(this, "dynamicValue");
    __publicField(this, "scope");
    __publicField(this, "type");
    __publicField(this, "factory");
    __publicField(this, "provider");
    __publicField(this, "constraint");
    __publicField(this, "onActivation");
    __publicField(this, "onDeactivation");
    this.id = A2(), this.activated = false, this.serviceIdentifier = t3, this.scope = n, this.type = b2.Invalid, this.constraint = (t4) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
  }
  clone() {
    const t3 = new _S(this.serviceIdentifier, this.scope);
    return t3.activated = t3.scope === v2.Singleton && this.activated, t3.implementationType = this.implementationType, t3.dynamicValue = this.dynamicValue, t3.scope = this.scope, t3.type = this.type, t3.factory = this.factory, t3.provider = this.provider, t3.constraint = this.constraint, t3.onActivation = this.onActivation, t3.onDeactivation = this.onDeactivation, t3.cache = this.cache, t3;
  }
};
var I2 = "Metadata key was used more than once in a parameter:";
var T2 = "NULL argument";
var D2 = "Key Not Found";
var N2 = "Ambiguous match found for serviceIdentifier:";
var C2 = "No matching bindings found for serviceIdentifier:";
var x2 = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
var R = (t3, n) => `onDeactivation() error in class ${t3}: ${n}`;
var E2 = class {
  getConstructorMetadata(t3) {
    return { compilerGeneratedMetadata: Reflect.getMetadata(g2, t3) ?? [], userGeneratedMetadata: Reflect.getMetadata(u2, t3) ?? {} };
  }
  getPropertiesMetadata(t3) {
    return Reflect.getMetadata(h2, t3) ?? {};
  }
};
var M2;
function B(t3) {
  return t3 instanceof RangeError || "Maximum call stack size exceeded" === t3.message;
}
!function(t3) {
  t3[t3.MultipleBindingsAvailable = 2] = "MultipleBindingsAvailable", t3[t3.NoBindingsAvailable = 0] = "NoBindingsAvailable", t3[t3.OnlyOneBindingAvailable = 1] = "OnlyOneBindingAvailable";
}(M2 || (M2 = {}));
function P(t3) {
  return "function" == typeof t3 ? t3.name : "symbol" == typeof t3 ? t3.toString() : t3;
}
function k2(t3, n, e2) {
  let i2 = "";
  const r4 = e2(t3, n);
  return 0 !== r4.length && (i2 = "\nRegistered bindings:", r4.forEach((t4) => {
    let n2 = "Object";
    null !== t4.implementationType && (n2 = j2(t4.implementationType)), i2 = `${i2}
 ${n2}`, t4.constraint.metaData && (i2 = `${i2} - ${t4.constraint.metaData}`);
  })), i2;
}
function q(t3, n) {
  return null !== t3.parentRequest && (t3.parentRequest.serviceIdentifier === n || q(t3.parentRequest, n));
}
function F(t3) {
  t3.childRequests.forEach((n) => {
    if (q(t3, n.serviceIdentifier)) {
      const t4 = function(t5) {
        const n2 = function t6(n3, e2 = []) {
          const i2 = P(n3.serviceIdentifier);
          return e2.push(i2), null !== n3.parentRequest ? t6(n3.parentRequest, e2) : e2;
        }(t5);
        return n2.reverse().join(" --> ");
      }(n);
      throw new Error(`Circular dependency found: ${t4}`);
    }
    F(n);
  });
}
function j2(t3) {
  if (null != t3.name && "" !== t3.name) return t3.name;
  {
    const n = t3.toString(), e2 = n.match(/^function\s*([^\s(]+)/);
    return null === e2 ? `Anonymous function: ${n}` : e2[1];
  }
}
function O2(t3) {
  return `{"key":"${t3.key.toString()}","value":"${t3.value.toString()}"}`;
}
var $ = class {
  constructor(t3) {
    __publicField(this, "id");
    __publicField(this, "container");
    __publicField(this, "plan");
    __publicField(this, "currentRequest");
    this.id = A2(), this.container = t3;
  }
  addPlan(t3) {
    this.plan = t3;
  }
  setCurrentRequest(t3) {
    this.currentRequest = t3;
  }
};
var V = class {
  constructor(t3, n) {
    __publicField(this, "key");
    __publicField(this, "value");
    this.key = t3, this.value = n;
  }
  toString() {
    return this.key === r3 ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
};
var W = class {
  constructor(t3, n) {
    __publicField(this, "parentContext");
    __publicField(this, "rootRequest");
    this.parentContext = t3, this.rootRequest = n;
  }
};
function G(n, e2) {
  const i2 = function(t3) {
    const n2 = Object.getPrototypeOf(t3.prototype), e3 = n2 == null ? void 0 : n2.constructor;
    return e3;
  }(e2);
  if (void 0 === i2 || i2 === Object) return 0;
  const r4 = _(n)(i2), s3 = r4.map((t3) => t3.metadata.filter((t4) => t4.key === o2)), a3 = [].concat.apply([], s3).length, c3 = r4.length - a3;
  return c3 > 0 ? c3 : G(n, i2);
}
var K = class _K {
  constructor(t3, n, e2, i2, r4) {
    __publicField(this, "id");
    __publicField(this, "serviceIdentifier");
    __publicField(this, "parentContext");
    __publicField(this, "parentRequest");
    __publicField(this, "bindings");
    __publicField(this, "childRequests");
    __publicField(this, "target");
    __publicField(this, "requestScope");
    this.id = A2(), this.serviceIdentifier = t3, this.parentContext = n, this.parentRequest = e2, this.target = r4, this.childRequests = [], this.bindings = Array.isArray(i2) ? i2 : [i2], this.requestScope = null === e2 ? /* @__PURE__ */ new Map() : null;
  }
  addChildRequest(t3, n, e2) {
    const i2 = new _K(t3, this.parentContext, this, n, e2);
    return this.childRequests.push(i2), i2;
  }
};
function H(t3) {
  return t3._bindingDictionary;
}
function U(t3, n, e2, i2, r4) {
  let s3 = z(e2.container, r4.serviceIdentifier), o3 = [];
  return s3.length === M2.NoBindingsAvailable && true === e2.container.options.autoBindInjectable && "function" == typeof r4.serviceIdentifier && t3.getConstructorMetadata(r4.serviceIdentifier).compilerGeneratedMetadata && (e2.container.bind(r4.serviceIdentifier).toSelf(), s3 = z(e2.container, r4.serviceIdentifier)), o3 = n ? s3 : s3.filter((t4) => {
    const n2 = new K(t4.serviceIdentifier, e2, i2, t4, r4);
    return t4.constraint(n2);
  }), function(t4, n2, e3, i3, r5) {
    switch (n2.length) {
      case M2.NoBindingsAvailable:
        if (i3.isOptional()) return n2;
        {
          const n3 = P(t4);
          let s4 = C2;
          throw s4 += function(t5, n4) {
            if (n4.isTagged() || n4.isNamed()) {
              let e4 = "";
              const i4 = n4.getNamedTag(), r6 = n4.getCustomTags();
              return null !== i4 && (e4 += O2(i4) + "\n"), null !== r6 && r6.forEach((t6) => {
                e4 += O2(t6) + "\n";
              }), ` ${t5}
 ${t5} - ${e4}`;
            }
            return ` ${t5}`;
          }(n3, i3), s4 += k2(r5, n3, z), null !== e3 && (s4 += `
Trying to resolve bindings for "${P(e3.serviceIdentifier)}"`), new Error(s4);
        }
      case M2.OnlyOneBindingAvailable:
        return n2;
      case M2.MultipleBindingsAvailable:
      default:
        if (i3.isArray()) return n2;
        {
          const n3 = P(t4);
          let e4 = `${N2} ${n3}`;
          throw e4 += k2(r5, n3, z), new Error(e4);
        }
    }
  }(r4.serviceIdentifier, o3, i2, r4, e2.container), o3;
}
function L(t3, n) {
  const e2 = n.isMultiInject ? d2 : c2, i2 = [new V(e2, t3)];
  return void 0 !== n.customTag && i2.push(new V(n.customTag.key, n.customTag.value)), true === n.isOptional && i2.push(new V(a2, true)), i2;
}
function Y(n, e2, i2, r4, s3, o3) {
  let a3, c3;
  if (null === s3) {
    a3 = U(n, e2, r4, null, o3), c3 = new K(i2, r4, null, a3, o3);
    const t3 = new W(r4, c3);
    r4.addPlan(t3);
  } else a3 = U(n, e2, r4, s3, o3), c3 = s3.addChildRequest(o3.serviceIdentifier, a3, o3);
  a3.forEach((e3) => {
    let i3 = null;
    if (o3.isArray()) i3 = c3.addChildRequest(e3.serviceIdentifier, e3, o3);
    else {
      if (null !== e3.cache) return;
      i3 = c3;
    }
    if (e3.type === b2.Instance && null !== e3.implementationType) {
      const s4 = function(n2, e4) {
        return _(n2)(e4);
      }(n, e3.implementationType);
      if (true !== r4.container.options.skipBaseClassChecks) {
        const t3 = G(n, e3.implementationType);
        if (s4.length < t3) {
          const t4 = `The number of constructor arguments in the derived class ${j2(e3.implementationType)} must be >= than the number of constructor arguments of its base class.`;
          throw new Error(t4);
        }
      }
      s4.forEach((t3) => {
        Y(n, false, t3.serviceIdentifier, r4, i3, t3);
      });
    }
  });
}
function z(t3, n) {
  let e2 = [];
  const i2 = H(t3);
  return i2.hasKey(n) ? e2 = i2.get(n) : null !== t3.parent && (e2 = z(t3.parent, n)), e2;
}
function J(t3, r4, s3, o3, a3, c3 = false) {
  const d3 = new $(r4), u3 = function(t4, r5, s4) {
    const o4 = L(r5, s4), a4 = v(o4);
    if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
    return new T("", a4, t4);
  }(s3, o3, a3);
  try {
    return Y(t3, c3, o3, d3, null, u3), d3;
  } catch (t4) {
    throw B(t4) && F(d3.plan.rootRequest), t4;
  }
}
function Q(t3) {
  return ("object" == typeof t3 && null !== t3 || "function" == typeof t3) && "function" == typeof t3.then;
}
function X(t3) {
  return !!Q(t3) || Array.isArray(t3) && t3.some(Q);
}
var Z = (t3, n, e2) => {
  t3.has(n.id) || t3.set(n.id, e2);
};
var tt = (t3, n) => {
  t3.cache = n, t3.activated = true, Q(n) && nt(t3, n);
};
var nt = async (t3, n) => {
  try {
    const e2 = await n;
    t3.cache = e2;
  } catch (n2) {
    throw t3.cache = null, t3.activated = false, n2;
  }
};
var et;
!function(t3) {
  t3.DynamicValue = "toDynamicValue", t3.Factory = "toFactory", t3.Provider = "toProvider";
}(et || (et = {}));
function rt(t3, n, e2) {
  let i2;
  if (n.length > 0) {
    const r4 = function(t4, n2) {
      return t4.reduce((t5, e3) => {
        const i3 = n2(e3);
        return e3.target.type === w2.ConstructorArgument ? t5.constructorInjections.push(i3) : (t5.propertyRequests.push(e3), t5.propertyInjections.push(i3)), t5.isAsync || (t5.isAsync = X(i3)), t5;
      }, { constructorInjections: [], isAsync: false, propertyInjections: [], propertyRequests: [] });
    }(n, e2), s3 = { ...r4, constr: t3 };
    i2 = r4.isAsync ? async function(t4) {
      const n2 = await ot(t4.constructorInjections), e3 = await ot(t4.propertyInjections);
      return st({ ...t4, constructorInjections: n2, propertyInjections: e3 });
    }(s3) : st(s3);
  } else i2 = new t3();
  return i2;
}
function st(t3) {
  const n = new t3.constr(...t3.constructorInjections);
  return t3.propertyRequests.forEach((e2, i2) => {
    const r4 = e2.target.identifier, s3 = t3.propertyInjections[i2];
    e2.target.isOptional() && void 0 === s3 || (n[r4] = s3);
  }), n;
}
async function ot(t3) {
  const n = [];
  for (const e2 of t3) Array.isArray(e2) ? n.push(Promise.all(e2)) : n.push(e2);
  return Promise.all(n);
}
function at(t3, n) {
  const e2 = function(t4, n2) {
    var _a4;
    if (Reflect.hasMetadata(y2, t4)) {
      const r4 = Reflect.getMetadata(y2, t4);
      try {
        return (_a4 = n2[r4.value]) == null ? void 0 : _a4.call(n2);
      } catch (n3) {
        if (n3 instanceof Error) throw new Error((e3 = t4.name, i2 = n3.message, `@postConstruct error in class ${e3}: ${i2}`));
      }
    }
    var e3, i2;
  }(t3, n);
  return Q(e2) ? e2.then(() => n) : n;
}
function ct(t3, n) {
  t3.scope !== v2.Singleton && function(t4, n2) {
    const e2 = `Class cannot be instantiated in ${t4.scope === v2.Request ? "request" : "transient"} scope.`;
    if ("function" == typeof t4.onDeactivation) throw new Error(R(n2.name, e2));
    if (Reflect.hasMetadata(p2, n2)) throw new Error(`@preDestroy error in class ${n2.name}: ${e2}`);
  }(t3, n);
}
var dt = (t3) => (n) => {
  n.parentContext.setCurrentRequest(n);
  const e2 = n.bindings, i2 = n.childRequests, r4 = n.target && n.target.isArray(), s3 = !(n.parentRequest && n.parentRequest.target && n.target && n.parentRequest.target.matchesArray(n.target.serviceIdentifier));
  if (r4 && s3) return i2.map((n2) => dt(t3)(n2));
  {
    if (n.target.isOptional() && 0 === e2.length) return;
    const i3 = e2[0];
    return gt(t3, n, i3);
  }
};
var ut = (t3, n) => {
  const e2 = ((t4) => {
    switch (t4.type) {
      case b2.Factory:
        return { factory: t4.factory, factoryType: et.Factory };
      case b2.Provider:
        return { factory: t4.provider, factoryType: et.Provider };
      case b2.DynamicValue:
        return { factory: t4.dynamicValue, factoryType: et.DynamicValue };
      default:
        throw new Error(`Unexpected factory type ${t4.type}`);
    }
  })(t3);
  return ((t4, n2) => {
    try {
      return t4();
    } catch (t5) {
      if (B(t5)) throw n2();
      throw t5;
    }
  })(() => e2.factory.bind(t3)(n), () => {
    return new Error((t4 = e2.factoryType, i2 = n.currentRequest.serviceIdentifier.toString(), `It looks like there is a circular dependency in one of the '${t4}' bindings. Please investigate bindings with service identifier '${i2}'.`));
    var t4, i2;
  });
};
var ht = (t3, n, e2) => {
  let i2;
  const r4 = n.childRequests;
  switch (((t4) => {
    let n2 = null;
    switch (t4.type) {
      case b2.ConstantValue:
      case b2.Function:
        n2 = t4.cache;
        break;
      case b2.Constructor:
      case b2.Instance:
        n2 = t4.implementationType;
        break;
      case b2.DynamicValue:
        n2 = t4.dynamicValue;
        break;
      case b2.Provider:
        n2 = t4.provider;
        break;
      case b2.Factory:
        n2 = t4.factory;
    }
    if (null === n2) {
      const n3 = P(t4.serviceIdentifier);
      throw new Error(`Invalid binding type: ${n3}`);
    }
  })(e2), e2.type) {
    case b2.ConstantValue:
    case b2.Function:
      i2 = e2.cache;
      break;
    case b2.Constructor:
      i2 = e2.implementationType;
      break;
    case b2.Instance:
      i2 = function(t4, n2, e3, i3) {
        ct(t4, n2);
        const r5 = rt(n2, e3, i3);
        return Q(r5) ? r5.then((t5) => at(n2, t5)) : at(n2, r5);
      }(e2, e2.implementationType, r4, dt(t3));
      break;
    default:
      i2 = ut(e2, n.parentContext);
  }
  return i2;
};
var lt = (t3, n, e2) => {
  let i2 = ((t4, n2) => n2.scope === v2.Singleton && n2.activated ? n2.cache : n2.scope === v2.Request && t4.has(n2.id) ? t4.get(n2.id) : null)(t3, n);
  return null !== i2 || (i2 = e2(), ((t4, n2, e3) => {
    n2.scope === v2.Singleton && tt(n2, e3), n2.scope === v2.Request && Z(t4, n2, e3);
  })(t3, n, i2)), i2;
};
var gt = (t3, n, e2) => lt(t3, e2, () => {
  let i2 = ht(t3, n, e2);
  return i2 = Q(i2) ? i2.then((t4) => yt(n, e2, t4)) : yt(n, e2, i2), i2;
});
function yt(t3, n, e2) {
  let i2 = pt(t3.parentContext, n, e2);
  const r4 = bt(t3.parentContext.container);
  let s3, o3 = r4.next();
  do {
    s3 = o3.value;
    const n2 = t3.parentContext, e3 = t3.serviceIdentifier, a3 = vt(s3, e3);
    i2 = Q(i2) ? _t2(a3, n2, i2) : ft(a3, n2, i2), o3 = r4.next();
  } while (true !== o3.done && !H(s3).hasKey(t3.serviceIdentifier));
  return i2;
}
var pt = (t3, n, e2) => {
  let i2;
  return i2 = "function" == typeof n.onActivation ? n.onActivation(t3, e2) : e2, i2;
};
var ft = (t3, n, e2) => {
  let i2 = t3.next();
  for (; true !== i2.done; ) {
    if (Q(e2 = i2.value(n, e2))) return _t2(t3, n, e2);
    i2 = t3.next();
  }
  return e2;
};
var _t2 = async (t3, n, e2) => {
  let i2 = await e2, r4 = t3.next();
  for (; true !== r4.done; ) i2 = await r4.value(n, i2), r4 = t3.next();
  return i2;
};
var vt = (t3, n) => {
  const e2 = t3._activations;
  return e2.hasKey(n) ? e2.get(n).values() : [].values();
};
var bt = (t3) => {
  const n = [t3];
  let e2 = t3.parent;
  for (; null !== e2; ) n.push(e2), e2 = e2.parent;
  return { next: () => {
    const t4 = n.pop();
    return void 0 !== t4 ? { done: false, value: t4 } : { done: true, value: void 0 };
  } };
};
var wt = (t3, n) => {
  const e2 = t3.parentRequest;
  return null !== e2 && (!!n(e2) || wt(e2, n));
};
var mt = (t3) => (n) => {
  const e2 = (e3) => null !== e3 && null !== e3.target && e3.target.matchesTag(t3)(n);
  return e2.metaData = new V(t3, n), e2;
};
var At = mt(r3);
var St = (t3) => (n) => {
  let e2 = null;
  if (null !== n) {
    if (e2 = n.bindings[0], "string" == typeof t3) return e2.serviceIdentifier === t3;
    {
      const e3 = n.bindings[0].implementationType;
      return t3 === e3;
    }
  }
  return false;
};
var It = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  when(t3) {
    return this._binding.constraint = t3, new Tt(this._binding);
  }
  whenTargetNamed(t3) {
    return this._binding.constraint = At(t3), new Tt(this._binding);
  }
  whenTargetIsDefault() {
    return this._binding.constraint = (t3) => {
      if (null === t3) return false;
      return null !== t3.target && !t3.target.isNamed() && !t3.target.isTagged();
    }, new Tt(this._binding);
  }
  whenTargetTagged(t3, n) {
    return this._binding.constraint = mt(t3)(n), new Tt(this._binding);
  }
  whenInjectedInto(t3) {
    return this._binding.constraint = (n) => null !== n && St(t3)(n.parentRequest), new Tt(this._binding);
  }
  whenParentNamed(t3) {
    return this._binding.constraint = (n) => null !== n && At(t3)(n.parentRequest), new Tt(this._binding);
  }
  whenParentTagged(t3, n) {
    return this._binding.constraint = (e2) => null !== e2 && mt(t3)(n)(e2.parentRequest), new Tt(this._binding);
  }
  whenAnyAncestorIs(t3) {
    return this._binding.constraint = (n) => null !== n && wt(n, St(t3)), new Tt(this._binding);
  }
  whenNoAncestorIs(t3) {
    return this._binding.constraint = (n) => null !== n && !wt(n, St(t3)), new Tt(this._binding);
  }
  whenAnyAncestorNamed(t3) {
    return this._binding.constraint = (n) => null !== n && wt(n, At(t3)), new Tt(this._binding);
  }
  whenNoAncestorNamed(t3) {
    return this._binding.constraint = (n) => null !== n && !wt(n, At(t3)), new Tt(this._binding);
  }
  whenAnyAncestorTagged(t3, n) {
    return this._binding.constraint = (e2) => null !== e2 && wt(e2, mt(t3)(n)), new Tt(this._binding);
  }
  whenNoAncestorTagged(t3, n) {
    return this._binding.constraint = (e2) => null !== e2 && !wt(e2, mt(t3)(n)), new Tt(this._binding);
  }
  whenAnyAncestorMatches(t3) {
    return this._binding.constraint = (n) => null !== n && wt(n, t3), new Tt(this._binding);
  }
  whenNoAncestorMatches(t3) {
    return this._binding.constraint = (n) => null !== n && !wt(n, t3), new Tt(this._binding);
  }
};
var Tt = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  onActivation(t3) {
    return this._binding.onActivation = t3, new It(this._binding);
  }
  onDeactivation(t3) {
    return this._binding.onDeactivation = t3, new It(this._binding);
  }
};
var Dt = class {
  constructor(t3) {
    __publicField(this, "_bindingWhenSyntax");
    __publicField(this, "_bindingOnSyntax");
    __publicField(this, "_binding");
    this._binding = t3, this._bindingWhenSyntax = new It(this._binding), this._bindingOnSyntax = new Tt(this._binding);
  }
  when(t3) {
    return this._bindingWhenSyntax.when(t3);
  }
  whenTargetNamed(t3) {
    return this._bindingWhenSyntax.whenTargetNamed(t3);
  }
  whenTargetIsDefault() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  }
  whenTargetTagged(t3, n) {
    return this._bindingWhenSyntax.whenTargetTagged(t3, n);
  }
  whenInjectedInto(t3) {
    return this._bindingWhenSyntax.whenInjectedInto(t3);
  }
  whenParentNamed(t3) {
    return this._bindingWhenSyntax.whenParentNamed(t3);
  }
  whenParentTagged(t3, n) {
    return this._bindingWhenSyntax.whenParentTagged(t3, n);
  }
  whenAnyAncestorIs(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
  }
  whenNoAncestorIs(t3) {
    return this._bindingWhenSyntax.whenNoAncestorIs(t3);
  }
  whenAnyAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
  }
  whenAnyAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
  }
  whenNoAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
  }
  whenNoAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
  }
  whenAnyAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
  }
  whenNoAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
  }
  onActivation(t3) {
    return this._bindingOnSyntax.onActivation(t3);
  }
  onDeactivation(t3) {
    return this._bindingOnSyntax.onDeactivation(t3);
  }
};
var Nt = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  inRequestScope() {
    return this._binding.scope = v2.Request, new Dt(this._binding);
  }
  inSingletonScope() {
    return this._binding.scope = v2.Singleton, new Dt(this._binding);
  }
  inTransientScope() {
    return this._binding.scope = v2.Transient, new Dt(this._binding);
  }
};
var Ct = class {
  constructor(t3) {
    __publicField(this, "_bindingInSyntax");
    __publicField(this, "_bindingWhenSyntax");
    __publicField(this, "_bindingOnSyntax");
    __publicField(this, "_binding");
    this._binding = t3, this._bindingWhenSyntax = new It(this._binding), this._bindingOnSyntax = new Tt(this._binding), this._bindingInSyntax = new Nt(t3);
  }
  inRequestScope() {
    return this._bindingInSyntax.inRequestScope();
  }
  inSingletonScope() {
    return this._bindingInSyntax.inSingletonScope();
  }
  inTransientScope() {
    return this._bindingInSyntax.inTransientScope();
  }
  when(t3) {
    return this._bindingWhenSyntax.when(t3);
  }
  whenTargetNamed(t3) {
    return this._bindingWhenSyntax.whenTargetNamed(t3);
  }
  whenTargetIsDefault() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  }
  whenTargetTagged(t3, n) {
    return this._bindingWhenSyntax.whenTargetTagged(t3, n);
  }
  whenInjectedInto(t3) {
    return this._bindingWhenSyntax.whenInjectedInto(t3);
  }
  whenParentNamed(t3) {
    return this._bindingWhenSyntax.whenParentNamed(t3);
  }
  whenParentTagged(t3, n) {
    return this._bindingWhenSyntax.whenParentTagged(t3, n);
  }
  whenAnyAncestorIs(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
  }
  whenNoAncestorIs(t3) {
    return this._bindingWhenSyntax.whenNoAncestorIs(t3);
  }
  whenAnyAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
  }
  whenAnyAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
  }
  whenNoAncestorNamed(t3) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
  }
  whenNoAncestorTagged(t3, n) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
  }
  whenAnyAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
  }
  whenNoAncestorMatches(t3) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
  }
  onActivation(t3) {
    return this._bindingOnSyntax.onActivation(t3);
  }
  onDeactivation(t3) {
    return this._bindingOnSyntax.onDeactivation(t3);
  }
};
var xt = class {
  constructor(t3) {
    __publicField(this, "_binding");
    this._binding = t3;
  }
  to(t3) {
    return this._binding.type = b2.Instance, this._binding.implementationType = t3, new Ct(this._binding);
  }
  toSelf() {
    if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
    const t3 = this._binding.serviceIdentifier;
    return this.to(t3);
  }
  toConstantValue(t3) {
    return this._binding.type = b2.ConstantValue, this._binding.cache = t3, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = v2.Singleton, new Dt(this._binding);
  }
  toDynamicValue(t3) {
    return this._binding.type = b2.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = t3, this._binding.implementationType = null, new Ct(this._binding);
  }
  toConstructor(t3) {
    return this._binding.type = b2.Constructor, this._binding.implementationType = t3, this._binding.scope = v2.Singleton, new Dt(this._binding);
  }
  toFactory(t3) {
    return this._binding.type = b2.Factory, this._binding.factory = t3, this._binding.scope = v2.Singleton, new Dt(this._binding);
  }
  toFunction(t3) {
    if ("function" != typeof t3) throw new Error("Value provided to function binding must be a function!");
    const n = this.toConstantValue(t3);
    return this._binding.type = b2.Function, this._binding.scope = v2.Singleton, n;
  }
  toAutoFactory(t3) {
    return this._binding.type = b2.Factory, this._binding.factory = (n) => () => n.container.get(t3), this._binding.scope = v2.Singleton, new Dt(this._binding);
  }
  toAutoNamedFactory(t3) {
    return this._binding.type = b2.Factory, this._binding.factory = (n) => (e2) => n.container.getNamed(t3, e2), new Dt(this._binding);
  }
  toProvider(t3) {
    return this._binding.type = b2.Provider, this._binding.provider = t3, this._binding.scope = v2.Singleton, new Dt(this._binding);
  }
  toService(t3) {
    this._binding.type = b2.DynamicValue, Object.defineProperty(this._binding, "cache", { configurable: true, enumerable: true, get: () => null, set(t4) {
    } }), this._binding.dynamicValue = (n) => {
      try {
        return n.container.get(t3);
      } catch (e2) {
        return n.container.getAsync(t3);
      }
    }, this._binding.implementationType = null;
  }
};
var Rt = class _Rt {
  constructor() {
    __publicField(this, "bindings");
    __publicField(this, "activations");
    __publicField(this, "deactivations");
    __publicField(this, "middleware");
    __publicField(this, "moduleActivationStore");
  }
  static of(t3, n, e2, i2, r4) {
    const s3 = new _Rt();
    return s3.bindings = t3, s3.middleware = n, s3.deactivations = i2, s3.activations = e2, s3.moduleActivationStore = r4, s3;
  }
};
var Et = class _Et {
  constructor() {
    __publicField(this, "_map");
    this._map = /* @__PURE__ */ new Map();
  }
  getMap() {
    return this._map;
  }
  add(t3, n) {
    if (this._checkNonNulish(t3), null == n) throw new Error(T2);
    const e2 = this._map.get(t3);
    void 0 !== e2 ? e2.push(n) : this._map.set(t3, [n]);
  }
  get(t3) {
    this._checkNonNulish(t3);
    const n = this._map.get(t3);
    if (void 0 !== n) return n;
    throw new Error(D2);
  }
  remove(t3) {
    if (this._checkNonNulish(t3), !this._map.delete(t3)) throw new Error(D2);
  }
  removeIntersection(t3) {
    this.traverse((n, e2) => {
      const i2 = t3.hasKey(n) ? t3.get(n) : void 0;
      if (void 0 !== i2) {
        const t4 = e2.filter((t5) => !i2.some((n2) => t5 === n2));
        this._setValue(n, t4);
      }
    });
  }
  removeByCondition(t3) {
    const n = [];
    return this._map.forEach((e2, i2) => {
      const r4 = [];
      for (const i3 of e2) {
        t3(i3) ? n.push(i3) : r4.push(i3);
      }
      this._setValue(i2, r4);
    }), n;
  }
  hasKey(t3) {
    return this._checkNonNulish(t3), this._map.has(t3);
  }
  clone() {
    const t3 = new _Et();
    return this._map.forEach((n, e2) => {
      n.forEach((n2) => {
        var i2;
        t3.add(e2, "object" == typeof (i2 = n2) && null !== i2 && "clone" in i2 && "function" == typeof i2.clone ? n2.clone() : n2);
      });
    }), t3;
  }
  traverse(t3) {
    this._map.forEach((n, e2) => {
      t3(e2, n);
    });
  }
  _checkNonNulish(t3) {
    if (null == t3) throw new Error(T2);
  }
  _setValue(t3, n) {
    n.length > 0 ? this._map.set(t3, n) : this._map.delete(t3);
  }
};
var Mt = class _Mt {
  constructor() {
    __publicField(this, "_map", /* @__PURE__ */ new Map());
  }
  remove(t3) {
    const n = this._map.get(t3);
    return void 0 === n ? this._getEmptyHandlersStore() : (this._map.delete(t3), n);
  }
  addDeactivation(t3, n, e2) {
    this._getModuleActivationHandlers(t3).onDeactivations.add(n, e2);
  }
  addActivation(t3, n, e2) {
    this._getModuleActivationHandlers(t3).onActivations.add(n, e2);
  }
  clone() {
    const t3 = new _Mt();
    return this._map.forEach((n, e2) => {
      t3._map.set(e2, { onActivations: n.onActivations.clone(), onDeactivations: n.onDeactivations.clone() });
    }), t3;
  }
  _getModuleActivationHandlers(t3) {
    let n = this._map.get(t3);
    return void 0 === n && (n = this._getEmptyHandlersStore(), this._map.set(t3, n)), n;
  }
  _getEmptyHandlersStore() {
    return { onActivations: new Et(), onDeactivations: new Et() };
  }
};
var Bt = class _Bt {
  constructor(t3) {
    __publicField(this, "id");
    __publicField(this, "parent");
    __publicField(this, "options");
    __publicField(this, "_middleware");
    __publicField(this, "_bindingDictionary");
    __publicField(this, "_activations");
    __publicField(this, "_deactivations");
    __publicField(this, "_snapshots");
    __publicField(this, "_metadataReader");
    __publicField(this, "_moduleActivationStore");
    const n = t3 || {};
    if ("object" != typeof n) throw new Error("Invalid Container constructor argument. Container options must be an object.");
    if (void 0 === n.defaultScope) n.defaultScope = v2.Transient;
    else if (n.defaultScope !== v2.Singleton && n.defaultScope !== v2.Transient && n.defaultScope !== v2.Request) throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');
    if (void 0 === n.autoBindInjectable) n.autoBindInjectable = false;
    else if ("boolean" != typeof n.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
    if (void 0 === n.skipBaseClassChecks) n.skipBaseClassChecks = false;
    else if ("boolean" != typeof n.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
    this.options = { autoBindInjectable: n.autoBindInjectable, defaultScope: n.defaultScope, skipBaseClassChecks: n.skipBaseClassChecks }, this.id = A2(), this._bindingDictionary = new Et(), this._snapshots = [], this._middleware = null, this._activations = new Et(), this._deactivations = new Et(), this.parent = null, this._metadataReader = new E2(), this._moduleActivationStore = new Mt();
  }
  static merge(t3, n, ...e2) {
    const i2 = new _Bt(), r4 = [t3, n, ...e2].map((t4) => H(t4)), s3 = H(i2);
    return r4.forEach((t4) => {
      var n2;
      n2 = s3, t4.traverse((t5, e3) => {
        e3.forEach((t6) => {
          n2.add(t6.serviceIdentifier, t6.clone());
        });
      });
    }), i2;
  }
  load(...t3) {
    const n = this._getContainerModuleHelpersFactory();
    for (const e2 of t3) {
      const t4 = n(e2.id);
      e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
    }
  }
  async loadAsync(...t3) {
    const n = this._getContainerModuleHelpersFactory();
    for (const e2 of t3) {
      const t4 = n(e2.id);
      await e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
    }
  }
  unload(...t3) {
    t3.forEach((t4) => {
      const n = this._removeModuleBindings(t4.id);
      this._deactivateSingletons(n), this._removeModuleHandlers(t4.id);
    });
  }
  async unloadAsync(...t3) {
    for (const n of t3) {
      const t4 = this._removeModuleBindings(n.id);
      await this._deactivateSingletonsAsync(t4), this._removeModuleHandlers(n.id);
    }
  }
  bind(t3) {
    return this._bind(this._buildBinding(t3));
  }
  rebind(t3) {
    return this.unbind(t3), this.bind(t3);
  }
  async rebindAsync(t3) {
    return await this.unbindAsync(t3), this.bind(t3);
  }
  unbind(t3) {
    if (this._bindingDictionary.hasKey(t3)) {
      const n = this._bindingDictionary.get(t3);
      this._deactivateSingletons(n);
    }
    this._removeServiceFromDictionary(t3);
  }
  async unbindAsync(t3) {
    if (this._bindingDictionary.hasKey(t3)) {
      const n = this._bindingDictionary.get(t3);
      await this._deactivateSingletonsAsync(n);
    }
    this._removeServiceFromDictionary(t3);
  }
  unbindAll() {
    this._bindingDictionary.traverse((t3, n) => {
      this._deactivateSingletons(n);
    }), this._bindingDictionary = new Et();
  }
  async unbindAllAsync() {
    const t3 = [];
    this._bindingDictionary.traverse((n, e2) => {
      t3.push(this._deactivateSingletonsAsync(e2));
    }), await Promise.all(t3), this._bindingDictionary = new Et();
  }
  onActivation(t3, n) {
    this._activations.add(t3, n);
  }
  onDeactivation(t3, n) {
    this._deactivations.add(t3, n);
  }
  isBound(t3) {
    let n = this._bindingDictionary.hasKey(t3);
    return !n && this.parent && (n = this.parent.isBound(t3)), n;
  }
  isCurrentBound(t3) {
    return this._bindingDictionary.hasKey(t3);
  }
  isBoundNamed(t3, n) {
    return this.isBoundTagged(t3, r3, n);
  }
  isBoundTagged(t3, r4, s3) {
    let o3 = false;
    if (this._bindingDictionary.hasKey(t3)) {
      const a3 = this._bindingDictionary.get(t3), c3 = function(t4, r5, s4) {
        const o4 = L(r5, s4), a4 = v(o4);
        if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
        const c4 = new T("", a4, "Variable"), d3 = new $(t4);
        return new K(r5, d3, null, [], c4);
      }(this, t3, { customTag: { key: r4, value: s3 }, isMultiInject: false });
      o3 = a3.some((t4) => t4.constraint(c3));
    }
    return !o3 && this.parent && (o3 = this.parent.isBoundTagged(t3, r4, s3)), o3;
  }
  snapshot() {
    this._snapshots.push(Rt.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
  }
  restore() {
    const t3 = this._snapshots.pop();
    if (void 0 === t3) throw new Error("No snapshot available to restore.");
    this._bindingDictionary = t3.bindings, this._activations = t3.activations, this._deactivations = t3.deactivations, this._middleware = t3.middleware, this._moduleActivationStore = t3.moduleActivationStore;
  }
  createChild(t3) {
    const n = new _Bt(t3 || this.options);
    return n.parent = this, n;
  }
  applyMiddleware(...t3) {
    const n = this._middleware ? this._middleware : this._planAndResolve();
    this._middleware = t3.reduce((t4, n2) => n2(t4), n);
  }
  applyCustomMetadataReader(t3) {
    this._metadataReader = t3;
  }
  get(t3) {
    const n = this._getNotAllArgs(t3, false, false);
    return this._getButThrowIfAsync(n);
  }
  async getAsync(t3) {
    const n = this._getNotAllArgs(t3, false, false);
    return this._get(n);
  }
  getTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, false, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async getTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, false, n, e2);
    return this._get(i2);
  }
  getNamed(t3, n) {
    return this.getTagged(t3, r3, n);
  }
  async getNamedAsync(t3, n) {
    return this.getTaggedAsync(t3, r3, n);
  }
  getAll(t3, n) {
    const e2 = this._getAllArgs(t3, n, false);
    return this._getButThrowIfAsync(e2);
  }
  async getAllAsync(t3, n) {
    const e2 = this._getAllArgs(t3, n, false);
    return this._getAll(e2);
  }
  getAllTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, false, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async getAllTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, false, n, e2);
    return this._getAll(i2);
  }
  getAllNamed(t3, n) {
    return this.getAllTagged(t3, r3, n);
  }
  async getAllNamedAsync(t3, n) {
    return this.getAllTaggedAsync(t3, r3, n);
  }
  resolve(t3) {
    const n = this.isBound(t3);
    n || this.bind(t3).toSelf();
    const e2 = this.get(t3);
    return n || this.unbind(t3), e2;
  }
  tryGet(t3) {
    const n = this._getNotAllArgs(t3, false, true);
    return this._getButThrowIfAsync(n);
  }
  async tryGetAsync(t3) {
    const n = this._getNotAllArgs(t3, false, true);
    return this._get(n);
  }
  tryGetTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, true, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async tryGetTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, false, true, n, e2);
    return this._get(i2);
  }
  tryGetNamed(t3, n) {
    return this.tryGetTagged(t3, r3, n);
  }
  async tryGetNamedAsync(t3, n) {
    return this.tryGetTaggedAsync(t3, r3, n);
  }
  tryGetAll(t3, n) {
    const e2 = this._getAllArgs(t3, n, true);
    return this._getButThrowIfAsync(e2);
  }
  async tryGetAllAsync(t3, n) {
    const e2 = this._getAllArgs(t3, n, true);
    return this._getAll(e2);
  }
  tryGetAllTagged(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, true, n, e2);
    return this._getButThrowIfAsync(i2);
  }
  async tryGetAllTaggedAsync(t3, n, e2) {
    const i2 = this._getNotAllArgs(t3, true, true, n, e2);
    return this._getAll(i2);
  }
  tryGetAllNamed(t3, n) {
    return this.tryGetAllTagged(t3, r3, n);
  }
  async tryGetAllNamedAsync(t3, n) {
    return this.tryGetAllTaggedAsync(t3, r3, n);
  }
  _preDestroy(t3, n) {
    var _a4;
    if (void 0 !== t3 && Reflect.hasMetadata(p2, t3)) {
      const e2 = Reflect.getMetadata(p2, t3);
      return (_a4 = n[e2.value]) == null ? void 0 : _a4.call(n);
    }
  }
  _removeModuleHandlers(t3) {
    const n = this._moduleActivationStore.remove(t3);
    this._activations.removeIntersection(n.onActivations), this._deactivations.removeIntersection(n.onDeactivations);
  }
  _removeModuleBindings(t3) {
    return this._bindingDictionary.removeByCondition((n) => n.moduleId === t3);
  }
  _deactivate(t3, n) {
    const e2 = null == n ? void 0 : Object.getPrototypeOf(n).constructor;
    try {
      if (this._deactivations.hasKey(t3.serviceIdentifier)) {
        const i3 = this._deactivateContainer(n, this._deactivations.get(t3.serviceIdentifier).values());
        if (Q(i3)) return this._handleDeactivationError(i3.then(async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2)), t3.serviceIdentifier);
      }
      const i2 = this._propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2);
      if (Q(i2)) return this._handleDeactivationError(i2, t3.serviceIdentifier);
    } catch (n2) {
      if (n2 instanceof Error) throw new Error(R(P(t3.serviceIdentifier), n2.message));
    }
  }
  async _handleDeactivationError(t3, n) {
    try {
      await t3;
    } catch (t4) {
      if (t4 instanceof Error) throw new Error(R(P(n), t4.message));
    }
  }
  _deactivateContainer(t3, n) {
    let e2 = n.next();
    for (; "function" == typeof e2.value; ) {
      const i2 = e2.value(t3);
      if (Q(i2)) return i2.then(async () => this._deactivateContainerAsync(t3, n));
      e2 = n.next();
    }
  }
  async _deactivateContainerAsync(t3, n) {
    let e2 = n.next();
    for (; "function" == typeof e2.value; ) await e2.value(t3), e2 = n.next();
  }
  _getContainerModuleHelpersFactory() {
    const t3 = (t4) => (n2) => {
      const e3 = this._buildBinding(n2);
      return e3.moduleId = t4, this._bind(e3);
    }, n = () => (t4) => {
      this.unbind(t4);
    }, e2 = () => async (t4) => this.unbindAsync(t4), i2 = () => (t4) => this.isBound(t4), r4 = (n2) => {
      const e3 = t3(n2);
      return (t4) => (this.unbind(t4), e3(t4));
    }, s3 = (t4) => (n2, e3) => {
      this._moduleActivationStore.addActivation(t4, n2, e3), this.onActivation(n2, e3);
    }, o3 = (t4) => (n2, e3) => {
      this._moduleActivationStore.addDeactivation(t4, n2, e3), this.onDeactivation(n2, e3);
    };
    return (a3) => ({ bindFunction: t3(a3), isboundFunction: i2(), onActivationFunction: s3(a3), onDeactivationFunction: o3(a3), rebindFunction: r4(a3), unbindAsyncFunction: e2(), unbindFunction: n() });
  }
  _bind(t3) {
    return this._bindingDictionary.add(t3.serviceIdentifier, t3), new xt(t3);
  }
  _buildBinding(t3) {
    const n = this.options.defaultScope || v2.Transient;
    return new S(t3, n);
  }
  async _getAll(t3) {
    return Promise.all(this._get(t3));
  }
  _get(t3) {
    const n = { ...t3, contextInterceptor: (t4) => t4, targetType: w2.Variable };
    if (this._middleware) {
      const t4 = this._middleware(n);
      if (null == t4) throw new Error("Invalid return type in middleware. Middleware must return!");
      return t4;
    }
    return this._planAndResolve()(n);
  }
  _getButThrowIfAsync(t3) {
    const n = this._get(t3);
    if (X(n)) throw new Error(`You are attempting to construct ${function(t4) {
      return "function" == typeof t4 ? `[function/class ${t4.name || "<anonymous>"}]` : "symbol" == typeof t4 ? t4.toString() : `'${t4}'`;
    }(t3.serviceIdentifier)} in a synchronous way but it has asynchronous dependencies.`);
    return n;
  }
  _getAllArgs(t3, n, e2) {
    return { avoidConstraints: !(n == null ? void 0 : n.enforceBindingConstraints), isMultiInject: true, isOptional: e2, serviceIdentifier: t3 };
  }
  _getNotAllArgs(t3, n, e2, i2, r4) {
    return { avoidConstraints: false, isMultiInject: n, isOptional: e2, key: i2, serviceIdentifier: t3, value: r4 };
  }
  _getPlanMetadataFromNextArgs(t3) {
    const n = { isMultiInject: t3.isMultiInject };
    return void 0 !== t3.key && (n.customTag = { key: t3.key, value: t3.value }), true === t3.isOptional && (n.isOptional = true), n;
  }
  _planAndResolve() {
    return (t3) => {
      let n = J(this._metadataReader, this, t3.targetType, t3.serviceIdentifier, this._getPlanMetadataFromNextArgs(t3), t3.avoidConstraints);
      n = t3.contextInterceptor(n);
      const e2 = function(t4) {
        return dt(t4.plan.rootRequest.requestScope)(t4.plan.rootRequest);
      }(n);
      return e2;
    };
  }
  _deactivateIfSingleton(t3) {
    if (t3.activated) return Q(t3.cache) ? t3.cache.then((n) => this._deactivate(t3, n)) : this._deactivate(t3, t3.cache);
  }
  _deactivateSingletons(t3) {
    for (const n of t3) {
      if (Q(this._deactivateIfSingleton(n))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
    }
  }
  async _deactivateSingletonsAsync(t3) {
    await Promise.all(t3.map(async (t4) => this._deactivateIfSingleton(t4)));
  }
  _propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2) {
    return this.parent ? this._deactivate.bind(this.parent)(t3, n) : this._bindingDeactivationAndPreDestroy(t3, n, e2);
  }
  async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2) {
    this.parent ? await this._deactivate.bind(this.parent)(t3, n) : await this._bindingDeactivationAndPreDestroyAsync(t3, n, e2);
  }
  _removeServiceFromDictionary(t3) {
    try {
      this._bindingDictionary.remove(t3);
    } catch (n) {
      throw new Error(`Could not unbind serviceIdentifier: ${P(t3)}`);
    }
  }
  _bindingDeactivationAndPreDestroy(t3, n, e2) {
    if ("function" == typeof t3.onDeactivation) {
      const i2 = t3.onDeactivation(n);
      if (Q(i2)) return i2.then(() => this._preDestroy(e2, n));
    }
    return this._preDestroy(e2, n);
  }
  async _bindingDeactivationAndPreDestroyAsync(t3, n, e2) {
    "function" == typeof t3.onDeactivation && await t3.onDeactivation(n), await this._preDestroy(e2, n);
  }
};
function qt(t3, n, e2, i2) {
  !function(t4) {
    if (void 0 !== t4) throw new Error(x2);
  }(n), jt(u2, t3, e2.toString(), i2);
}
function Ft(t3) {
  let n = [];
  if (Array.isArray(t3)) {
    n = t3;
    const e2 = function(t4) {
      const n2 = /* @__PURE__ */ new Set();
      for (const e3 of t4) {
        if (n2.has(e3)) return e3;
        n2.add(e3);
      }
    }(n.map((t4) => t4.key));
    if (void 0 !== e2) throw new Error(`${I2} ${e2.toString()}`);
  } else n = [t3];
  return n;
}
function jt(t3, n, e2, i2) {
  const r4 = Ft(i2);
  let s3 = {};
  Reflect.hasOwnMetadata(t3, n) && (s3 = Reflect.getMetadata(t3, n));
  let o3 = s3[e2];
  if (void 0 === o3) o3 = [];
  else for (const t4 of o3) if (r4.some((n2) => n2.key === t4.key)) throw new Error(`${I2} ${t4.key.toString()}`);
  o3.push(...r4), s3[e2] = o3, Reflect.defineMetadata(t3, s3, n);
}
function Ot(t3) {
  return (n, e2, i2) => {
    "number" == typeof i2 ? qt(n, e2, i2, t3) : function(t4, n2, e3) {
      if (void 0 !== t4.prototype) throw new Error(x2);
      jt(h2, t4.constructor, n2, e3);
    }(n, e2, t3);
  };
}
function Gt() {
  return function(t3) {
    if (Reflect.hasOwnMetadata(l2, t3)) throw new Error("Cannot apply @injectable decorator multiple times.");
    const n = Reflect.getMetadata(g2, t3) || [];
    return Reflect.defineMetadata(l2, n, t3), t3;
  };
}
function Ut(t3) {
  return (n) => (e2, i2, r4) => {
    if (void 0 === n) {
      const t4 = "function" == typeof e2 ? e2.name : e2.constructor.name;
      throw new Error(`@inject called with undefined this could mean that the class ${t4} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`);
    }
    Ot(new V(t3, n))(e2, i2, r4);
  };
}
var Lt = Ut(c2);
var Jt = Ut(d2);
function Xt(t3, n) {
  return () => (e2, i2) => {
    const r4 = new V(t3, i2);
    if (Reflect.hasOwnMetadata(t3, e2.constructor)) throw new Error(n);
    Reflect.defineMetadata(t3, r4, e2.constructor);
  };
}
var Zt = Xt(y2, "Cannot apply @postConstruct decorator multiple times in the same class");
var tn = Xt(p2, "Cannot apply @preDestroy decorator multiple times in the same class");

// ../../node_modules/.pnpm/@quested+sdk@0.1.7_reflect-metadata@0.1.14/node_modules/@quested/sdk/dist/index.mjs
function __decorate(decorators, target, key, desc) {
  var c3 = arguments.length, r4 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r4 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r4 = (c3 < 3 ? d3(r4) : c3 > 3 ? d3(target, key, r4) : d3(target, key)) || r4;
  return c3 > 3 && r4 && Object.defineProperty(target, key, r4), r4;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var CONFIG_INJECT_KEY = Symbol("CONFIG_INJECT_KEY");
var logLevelOrder = {
  debug: 0,
  info: 1,
  log: 2,
  warn: 3,
  error: 4
};
var LoggerService = class LoggerService2 {
  constructor(options) {
    var _a4, _b2;
    this.options = options;
    this.logLevel = (_a4 = this.options.logLevel) !== null && _a4 !== void 0 ? _a4 : "log";
    this.logger = (_b2 = this.options.logger) !== null && _b2 !== void 0 ? _b2 : console;
  }
  debug(...args) {
    if (logLevelOrder[this.logLevel] <= logLevelOrder.debug) {
      this.logger.debug(...args);
    }
  }
  info(...args) {
    if (logLevelOrder[this.logLevel] <= logLevelOrder.info) {
      this.logger.info(...args);
    }
  }
  log(...args) {
    if (logLevelOrder[this.logLevel] <= logLevelOrder.log) {
      this.logger.log(...args);
    }
  }
  warn(...args) {
    if (logLevelOrder[this.logLevel] <= logLevelOrder.warn) {
      this.logger.warn(...args);
    }
  }
  error(...args) {
    if (logLevelOrder[this.logLevel] <= logLevelOrder.error) {
      this.logger.error(...args);
    }
  }
};
LoggerService = __decorate([
  Gt(),
  __param(0, Lt(CONFIG_INJECT_KEY)),
  __metadata("design:paramtypes", [Object])
], LoggerService);
var BridgeService = class BridgeService2 {
  constructor(logger) {
    this.logger = logger;
    this.TIMEOUT_MS = 5e3;
  }
  send(activityId, eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      this.logger.log(activityId, eventType, payload);
      window.parent.postMessage({
        type: eventType,
        source: activityId,
        payload
      }, "*");
    });
  }
  waitForReply(activityId, eventType) {
    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (event.data.type === eventType && event.data.source === activityId) {
          cleanup();
          resolve(event.data.payload);
        }
      };
      const timeout = setTimeout(() => {
        cleanup();
        reject(new Error(`Timeout waiting for reply to ${eventType} after ${this.TIMEOUT_MS}ms`));
      }, this.TIMEOUT_MS);
      const cleanup = () => {
        window.removeEventListener("message", listener);
        clearTimeout(timeout);
      };
      window.addEventListener("message", listener);
    });
  }
  sendAndWaitForReply(activityId, eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.send(activityId, eventType, payload);
      return this.waitForReply(activityId, eventType);
    });
  }
};
BridgeService = __decorate([
  Gt(),
  __param(0, Lt(LoggerService)),
  __metadata("design:paramtypes", [LoggerService])
], BridgeService);
var PlayerService = class PlayerService2 {
  constructor(bridgeService, options) {
    this.bridgeService = bridgeService;
    this.options = options;
  }
  me() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.bridgeService.sendAndWaitForReply(this.options.activityId, "getProfile", {});
    });
  }
  trackEvent(event, data) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.bridgeService.send(this.options.activityId, event, data);
    });
  }
  updateProfileSpecification(id, value) {
    return this.bridgeService.send(this.options.activityId, "system:updateProfileSpecification", { id, value });
  }
  getGameProperty(key) {
    return this.bridgeService.sendAndWaitForReply(this.options.activityId, "system:getGameProperty", { key });
  }
  setGameProperty(key, value) {
    return this.bridgeService.send(this.options.activityId, "system:setGameProperty", { key, value });
  }
  getAllLists() {
    return this.bridgeService.sendAndWaitForReply(this.options.activityId, "system:getAllLists", {});
  }
  removeFromList(listId, itemId) {
    return this.bridgeService.send(this.options.activityId, "system:removeFromList", { listId, itemId });
  }
  addToList(listId, itemId) {
    return this.bridgeService.send(this.options.activityId, "system:addToList", { listId, itemId });
  }
};
PlayerService = __decorate([
  Gt(),
  __param(0, Lt(BridgeService)),
  __param(1, Lt(CONFIG_INJECT_KEY)),
  __metadata("design:paramtypes", [BridgeService, Object])
], PlayerService);
var Components = [PlayerService, LoggerService, BridgeService];
var create = (options) => {
  let isInitialized = false;
  const container = new Bt();
  container.bind(CONFIG_INJECT_KEY).toConstantValue(options);
  for (const provider of Components) {
    container.bind(provider).toSelf().inSingletonScope();
  }
  handleInstanceInitForComponent(container, Components).then(() => {
    var _a4;
    (_a4 = options.onReady) === null || _a4 === void 0 ? void 0 : _a4.call(options);
    isInitialized = true;
  });
  return {
    _container: container,
    api: {
      player: container.get(PlayerService)
    },
    isInitialized: () => isInitialized
  };
};
var handleInstanceInitForComponent = (container, components) => __awaiter(void 0, void 0, void 0, function* () {
  for (const provider of components) {
    const component = container.get(provider);
    if (component.onInstanceInit) {
      yield component.onInstanceInit();
    }
  }
});
var instance;
var init = (options) => {
  instance = create(options);
};
export {
  create,
  init,
  instance
};
/*! Bundled license information:

@quested/sdk/dist/index.mjs:
  (*!
   * @quested/sdk v0.1.7
   * (c) Yevhenii Rachkovan
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@quested_sdk.js.map
